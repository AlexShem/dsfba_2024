---
title: "Data Science for Business Analytics"
subtitle: "Control Flow and Functions"
author: "Thibault Vatter [thibault.vatter@hesge.ch]"
date: "09/10/2023"
format: 
    beamer:
        include-in-header: latex/header.tex
        fontsize: 10pt
execute:
    echo: true
---

```{r setup, include = FALSE, echo = FALSE}
source("common.R")
library(tidyverse)
library(knitr)
set.seed(0)
```

## Today

* Control flow:
  * __Choices__:
      * E.g. `if()`, `ifelse()`.
      * Allows to run different code depending on the input.
  * __Loops__:
      * E.g. `for`, `while`, `repeat`.
      * Allows to repeatedly run code, typically with changing options.
  <!-- * You might want to have a look at chapter 8 for condition system (messages, warnings, and errors)... -->
* Reducing code duplication:
  * Three main benefits:
    *  Easier to see the intent of your code.
    *  Easier to respond to changes in requirements.
    *  Likely to have fewer bugs.
  * __Functions__: identify repeated patterns of code and extract them out into independent pieces.
  * __Iteration__: helps you when you need to do the same thing to multiple inputs.

# Choices

## `if()` statements

* The basic idea for `if` statements:
    * If `condition` is `TRUE`, `true_action` is evaluated.
    * If `condition` is `FALSE`, the optional `false_action` is evaluated.

```{r, eval = FALSE}
if (condition) true_action
if (condition) true_action else false_action
```

* Typically, actions are compound statements contained within `{`.

```{r}
grade <- function(x) {
  if (x > 90) {
    "A"
  } else if (x > 80) {
    "B"
  } else if (x > 50) {
    "C"
  } else {
    "F"
  }
}
```

## `if()` statements cont'd

* `if` returns a value so that you can assign the results:
    + Only do that when it fits on one line; otherwise hard to read.

```{r}
x1 <- if (TRUE) 1 else 2
x2 <- if (FALSE) 1 else 2

c(x1, x2)
```

* When using `if` without `else`:
    + Returns `NULL` if the condition is `FALSE`.
    + Useful with functions like `c()`/`paste()` dropping `NULL` inputs.

```{r}
greet <- function(name, birthday = FALSE) {
  paste0("Hi ", name, if (birthday) " and HAPPY BIRTHDAY")
}
greet("Maria", FALSE)
greet("Jaime", TRUE)
```

## Invalid inputs

* The `condition` should evaluate to a single `TRUE` or `FALSE`:

```{r, error = TRUE}
if ("x") 1
if (logical()) 1
if (NA) 1
if (c(TRUE, FALSE)) 1
```

## Vectorised `if()` statements

* `if` only works with a single `TRUE` or `FALSE`.
* What if you have a vector of logical values?
* Answer: `ifelse()`
    + Vectorized function with `test`, `yes`, and `no` vectors (recycled).
    + Missing values propagated into the output.
    + Advice: use only when `yes` and `no` vectors are of the same type.

```{r}
x <- 1:9
ifelse(x %% 5 == 0, "XXX", as.character(x))
ifelse(x %% 2 == 0, "even", "odd")
```

* For any number of condition-vector pairs:

```{r}
dplyr::case_when(
  x %% 35 == 0 ~ "fizz buzz",
  x %% 5 == 0 ~ "fizz",
  x %% 7 == 0 ~ "buzz",
  TRUE ~ as.character(x)
  )
```

<!-- ## `switch()` statements -->

<!-- * Lets you replace code like: -->

<!-- ```{r} -->
<!-- x_option <- function(x) { -->
<!--   if (x == "a") { -->
<!--     "option 1" -->
<!--   } else if (x == "b") { -->
<!--     "option 2" -->
<!--   } else { -->
<!--     stop("Invalid `x` value") -->
<!--   } -->
<!-- } -->
<!-- ``` -->

<!-- * With: -->

<!-- ```{r} -->
<!-- x_option <- function(x) { -->
<!--   switch(x, -->
<!--     a = "option 1", -->
<!--     b = "option 2", -->
<!--     stop("Invalid `x` value") -->
<!--   ) -->
<!-- } -->
<!-- ``` -->

<!-- ## `switch()` statements cont'd -->

<!-- :::: {.columns} -->
<!-- ::: {.column width='48%'} -->

<!-- * Last component should always throw an error. -->

<!-- ::: -->
<!-- ::: {.column width='48%'} -->

<!-- ```{r} -->
<!-- (switch("c", a = 1, b = 2)) -->
<!-- ``` -->

<!-- ::: -->
<!-- :::: -->

<!-- :::: {.columns} -->
<!-- ::: {.column width='48%'} -->

<!-- * When multiple inputs share an output: -->
<!--     + Use empty right hand sides of `=`. -->
<!--     + Same as C's `switch` statement. -->

<!-- ::: -->
<!-- ::: {.column width='48%'} -->

<!-- ```{r} -->
<!-- legs <- function(x) { -->
<!--   switch(x, -->
<!--     cow = , -->
<!--     horse = , -->
<!--     dog = 4, -->
<!--     human = , -->
<!--     chicken = 2, -->
<!--     plant = 0, -->
<!--     stop("Unknown input") -->
<!--   ) -->
<!-- } -->
<!-- legs("cow") -->
<!-- legs("dog") -->
<!-- ``` -->

<!-- ::: -->
<!-- :::: -->

<!-- * `switch()` with a numeric `x` is not recommended. -->

<!-- is harder to read, and has undesirable failure modes if `x` is a not a whole number. I recommend using `switch()` only with character inputs. -->

# Loops

## For loops

* Let's compute the median of each column:

```{r}
df <- tibble(a = rnorm(10), 
             b = rnorm(10), 
             c = rnorm(10), 
             d = rnorm(10))

c(median(df$a), median(df$b), median(df$c), median(df$d))
```

* What's "wrong" here?

\pause

* A better solution:

```{r}
output <- vector("double", ncol(df))  # 1. output
for (i in seq_along(df)) {            # 2. sequence
  output[[i]] <- median(df[[i]])      # 3. body
}
output
```

## For loops cont'd

* `for` loops are used to iterate over items in a vector.

```{r, eval = FALSE}
for (item in vector) perform_action
```

* For each item in `vector`, `perform_action` is called once; updating the value of `item` each time.

```{r}
for (i in 1:3) {
  print(i)
}
```

* When iterating over indices, use short names like `i`, `j`, or `k`.
* Important: `for` assigns the `item` to the current environment.

```{r}
i <- 100
for (i in 1:3) {}
i
```

## Early termination

* Two ways to terminate a `for` loop early:
    * `next` exits the current iteration.
    * `break` exits the entire `for` loop.

```{r}
for (i in 1:10) {
  if (i < 3)
    next

  print(i)

  if (i >= 5)
    break
}
```

## Common pitfalls

* Common pitfalls to watch out for when using `for`:
    + Preallocation.
    + Iteration over e.g. `1:length(x)`.
    <!-- + Iteration over S3 vectors. -->

* Preallocation:
    + If you're generating data, preallocate the output.
    + Otherwise the loop will be very slow.
    + `vector()` function is helpful.

```{r}
means <- c(1, 50, 20)
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```

## Common pitfalls cont'd

* Next, beware of iterating over `1:length(x)`, which will fail in unhelpful ways if `x` has length 0.

\vspace{-0.1cm}

```{r, error = TRUE}
means <- c()
out <- vector("list", length(means))
for (i in 1:length(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}

# The reason? `:` works with both increasing and decreasing sequences.
1:length(means)
```

\vspace{-0.1cm}

* Use `seq_along(x)` instead.

\vspace{-0.1cm}

```{r}
seq_along(means)

out <- vector("list", length(means))
for (i in seq_along(means)) {
  out[[i]] <- rnorm(10, means[[i]])
}
```

<!-- ## Common pitfalls cont'd -->

<!-- * Finally, problems arise when iterating over S3 vectors, as loops typically strip the attributes. -->

<!-- ```{r} -->
<!-- xs <- as.Date(c("2020-01-01", "2010-01-01")) -->
<!-- for (x in xs) { -->
<!--   print(x) -->
<!-- } -->
<!-- ``` -->

<!-- * Work around this by using `[[`. -->

<!-- ```{r} -->
<!-- for (i in seq_along(xs)) { -->
<!--   print(xs[[i]]) -->
<!-- } -->
<!-- ``` -->

## Related tools

* `for` loops:
    * Useful when known in advance the set of values to iterate over.
    * Otherwise:
        * `while(condition) action`: performs `action` while `condition` is `TRUE`.
        * `repeat(action)`: repeats `action` forever (i.e. until it encounters `break`).
        * Possible to write any `for` using `while`, and any `while` using `repeat`, but not the converse.
        * Good practice to use the least-flexible (i.e., simplest) solution to a problem.
<!-- * R does not have a `do {action} while (condition)` syntax found in other languages. -->
* Generally speaking you shouldn't need to use `for` loops for \redbf{data analysis tasks}, we'll see better solutions.

# Functions

## Functions

* Two __important ideas__:
    * Functions can be broken down into three components: arguments, body, and environment.
    * Functions are objects, just as vectors are objects.
* In the following:
    * __The basics:__ 
        * How to create functions.
        * The three main components of a function.
        * How can a function exit.
        * Anonymous functions.
        <!-- * Lazy evaluation. -->
        * The special `...` argument.
    <!-- * __Function composition:__ the three common forms in R. -->
    * __Lexical scoping:__ how R finds the value associated with a given name.
        * Name masking.
        * Functions versus variables.
        * A fresh start.
        * Dynamic lookup.
    <!-- * __Lazy evaluation:__ the fact that function arguments are only evaluated when used for the first time. -->
    <!-- * __The special `...` argument:__ how to pass on extra arguments to another function. -->
    <!-- * __Exiting a function:__ and exit handlers. -->
    <!-- * __Function forms:__ the prefix form and more. -->

## Function components

* A function has three parts: 
    * The `formals()`, the arguments controlling how you call the function.
    * The `body()`, the code inside the function.
    * The `environment()`, the data structure determining how the function finds the values associated with the names.
    
:::: {.columns}
::: {.column width='48%'}
    
```{r}
f02 <- function(x, y) {
  # A comment
  x + y
}
formals(f02)
body(f02)
environment(f02)
```

:::
::: {.column width='48%'}

```{r, echo = FALSE}
knitr::include_graphics("figures/functions/components.png")
```

:::
::::

## Primitive functions

* One exception to the three components rule.
* Call C code directly. 

```{r}
sum
`[`
```

* Type is either `builtin` or `special`.

```{r}
typeof(sum)
typeof(`[`)
```

* `formals()`, `body()`, and `environment()` are all `NULL`. 

```{r}
formals(sum)
body(sum)
environment(sum)
```


## Exiting a function

* Most functions exit in one of two ways: 
    * They either return a value, indicating success.
    * Or they throw an error, indicating failure. 
* In the next few slides:
    * Return values.
        * Implicit versus explicit.
        * Visible versus invisible.
    * Errors.

## Implicit versus explicit returns

* Implicit, where the last evaluated expression is the return value.

```{r}
j01 <- function(x) {
  if (x < 10) {
    0
  } else {
    10
  }
}
j01(5)
j01(15)
```

* Explicit, by calling `return()`.

```{r}
j02 <- function(x) {
  if (x < 10) {
    return(0)
  } else {
    return(10)
  }
}
```
    
<!-- ## Invisible values -->

<!-- * Most functions return visibly: calling the function in an interactive context prints the result. -->

<!-- ```{r} -->
<!-- j03 <- function() 1 -->
<!-- j03() -->
<!-- ``` -->

<!-- * Applying `invisible()` to the last value prevents this. -->

<!-- ```{r} -->
<!-- j04 <- function() invisible(1) -->
<!-- j04() -->
<!-- ``` -->

<!-- * Verify that the value exists with `print` or `()`. -->

<!-- ```{r} -->
<!-- print(j04()) -->

<!-- (j04()) -->
<!-- ``` -->

<!-- ## Invisible values cont'd -->

<!-- * The most common function that returns invisibly is `<-`. -->

<!-- ```{r} -->
<!-- a <- 2 -->
<!-- (a <- 2) -->
<!-- ``` -->

<!-- * This is what makes it possible to chain assignments. -->

<!-- ```{r} -->
<!-- a <- b <- c <- d <- 2 -->
<!-- ``` -->

<!-- * Functions called primarily for a side effect (like `<-`, `print()`, or `plot()`) should return an invisible value (often the value of the first argument). -->

## Errors

* If a function cannot complete its assigned task, it should throw an error with `stop()`:
    * Immediately terminates the execution of the function.
    * Indicates that something has gone wrong, and forces the user to deal with the problem.

```{r, error = TRUE}
j05 <- function() {
  stop("I'm an error")
  return(10)
}
j05()
```

* Some languages rely on special return values to indicate problems, but in R you should always throw an error.


## Anonymous function

* Unlike in many other languages, no special syntax: 
    * Create a function object (with `function`).
    * Bind it to a name with `<-`.

```{r}
f01 <- function(x) {
  sin(x)
}
```


* ... but the binding step is not compulsory!
* A function without a name is called an __anonymous function__:

```{r}
integrate(function(x) sin(x), 0, pi)
sapply(1:10, function(x) x + 1)
```

<!-- ## Lazy evaluation -->

<!-- * In R, function arguments are __lazily evaluated__: -->
<!--     * Only evaluated if accessed.  -->
<!--     * What will this code return? -->

<!-- ```{r, results="hide"} -->
<!-- h01 <- function(x) { -->
<!--   10 -->
<!-- } -->
<!-- h01(stop("This is an error!")) -->
<!-- ``` -->

<!-- * Allows to include expensive computations in function arguments that are only evaluated if needed. -->

## `...`  (dot-dot-dot)

* The special argument `...` (pronounced dot-dot-dot). 
    * Makes a function take any number of additional arguments. 
    * In other programming languages:
        * This is often called _varargs_ (short for variable arguments).
        * A function that uses it is said to be variadic. 
* Can pass those additional arguments on to another function.

```{r}
i01 <- function(y, z) {
  list(y = y, z = z)
}

i02 <- function(x, ...) {
  i01(...)
}

str(i02(x = 1, y = 2, z = 3))
```

<!-- ## Invoking a function -->

<!-- * The standard way: -->

<!-- ```{r} -->
<!-- mean(1:10, na.rm = TRUE) -->
<!-- ``` -->

<!-- * The alternative way: -->

<!-- ```{r} -->
<!-- args <- list(1:10, na.rm = TRUE) -->
<!-- do.call(mean, args) -->
<!-- ``` -->

<!-- ## Function composition -->

<!-- * Imagine you want to compute the population standard deviation using `sqrt()` and `mean()`. -->

<!-- ```{r} -->
<!-- square <- function(x) x^2 -->
<!-- deviation <- function(x) x - mean(x) -->
<!-- ``` -->

<!-- * Either nest the function calls. -->

<!-- ```{r} -->
<!-- x <- runif(100) -->

<!-- sqrt(mean(square(deviation(x)))) -->
<!-- ``` -->

<!-- * Or save the intermediate results as variables. -->

<!-- ```{r} -->
<!-- out <- deviation(x) -->
<!-- out <- square(out) -->
<!-- out <- mean(out) -->
<!-- out <- sqrt(out) -->
<!-- out -->
<!-- ``` -->

<!-- ## Function composition cont'd -->

<!-- :::: {.columns} -->
<!-- ::: {.column width='68%'} -->

<!-- * The third option using the `magrittr` package:  -->
<!--     * The operator `%>%`, called __pipe__ and pronounced as "and then". -->

<!-- ::: -->
<!-- ::: {.column width='28%'} -->

<!-- ```{r, message=FALSE} -->
<!-- library(magrittr) -->

<!-- x %>% -->
<!--   deviation() %>% -->
<!--   square() %>% -->
<!--   mean() %>% -->
<!--   sqrt() -->
<!-- ``` -->

<!-- ::: -->
<!-- :::: -->

<!-- * Advantages: -->
<!--     * Focus on the high-level composition of functions, not the low-level flow of data.  -->
<!--     * Focus on what's being done (the verbs), not on what's being modified (the nouns).  -->
<!--     * Makes your code more readable by: -->
<!--         * Structuring sequences of data operations left-to-right. -->
<!--         * Minimizing the need for local variables and function definitions. -->
<!--         * Making it easy to add steps anywhere in the sequence. -->

<!-- ## Basic piping -->

<!-- * `x %>% f` is equivalent to `f(x)` -->
<!-- * `x %>% f(y)` is equivalent to `f(x, y)` -->
<!-- * `x %>% f(y) %>% g(z)` is equivalent to `g(f(x, y), z)` -->

<!-- ```{r} -->
<!-- x <- 1:10 -->
<!-- y <- x + 1 -->
<!-- z <- y + 1 -->
<!-- f <- function(x, y) x + y -->

<!-- x %>% sum -->
<!-- x %>% f(y) -->
<!-- x %>% f(y) %>% f(z) -->
<!-- ``` -->

<!-- ## The argument ("dot") placeholder -->

<!-- * `x %>% f(y, .)` is equivalent to `f(y, x)` -->
<!-- * `x %>% f(y, z = .)` is equivalent to `f(y, z = x)` -->

<!-- ```{r} -->
<!-- x <- 1:10 -->
<!-- y <- 2 * x -->
<!-- f <- function(z, y) y / z -->

<!-- x %>% f(y, .) -->
<!-- x %>% f(y, z = .) -->
<!-- ``` -->

<!-- ## Function composition cont'd -->

<!-- * Each of the three options has its own strengths and weaknesses: -->
<!--     * Nesting, `f(g(x))`: -->
<!--         * Concise, and well suited for short sequences.  -->
<!--         * Longer sequences harder to read (inside out \& right to left).  -->
<!--         * Arguments can get spread out over long distances creating the [Dagwood sandwich](https://en.wikipedia.org/wiki/Dagwood_sandwich) problem. -->
<!--     * Intermediate objects, `y <- f(x); g(y)`: -->
<!--         * Requires you to name intermediate objects. -->
<!--         * A strength when objects are important, but a weakness when values are truly intermediate. -->
<!--     * Piping, `x %>% f() %>% g()`: -->
<!--         * Allows to read code in straightforward left-to-right fashion. -->
<!--         * Doesn't require to name intermediate objects. -->
<!--         * Only for linear sequences of transformations of a single object. -->
<!-- * Most code use a combination of all three styles, but... -->
<!-- * \redbf{Piping is more common in data analysis code!} -->

# Lexical scoping

## Lexical scoping

* __Scoping:__ the act of finding the value associated with a name.
* What does the following code return?

```{r, results = "hide"}
x <- 10
g01 <- function() {
  x <- 20
  x
}

g01()
```

* R uses __lexical scoping__[^dyn-scope]: 
    * Looks up the values of names based on how a function is defined, not how it is called.
    * Follows four primary rules:
        * Name masking
        * Functions versus variables
        * A fresh start
        * Dynamic lookup

[^dyn-scope]: but possible to override the default rules.

## Name masking

* Names defined inside a function mask names defined outside.

```{r}
x <- 10
y <- 20
g02 <- function() {
  x <- 1
  y <- 2
  c(x, y)
}
g02()
```

* If a name isn't defined inside a function, R looks one level up.

```{r}
x <- 2
g03 <- function() {
  y <- 1
  c(x, y)
}
g03()
y
```

## Name masking cont'd

* Same applies if a function is defined inside another function:
    * First, R looks inside the current function. 
    * Then, where that function was defined (and so on, all the way up to the global environment). 
    * Finally, in other loaded packages. 
* What does the following code return?

```{r, results = "hide"}
x <- 1
g04 <- function() {
  y <- 2
  i <- function() {
    z <- 3
    c(x, y, z)
  }
  i()
}
g04()
```

## Functions versus variables

* Functions are ordinary objects, the same rules apply to them.

```{r}
g07 <- function(x) x + 1
g08 <- function() {
  g07 <- function(x) x + 100
  g07(10)
}
g08()
```

* When a function and a non-function share the same name, the rules get a little more complicated.
    * For function calls, R ignores non-functions when scoping.

```{r}
g09 <- function(x) x + 100
g10 <- function() {
  g09 <- 10
  g09(g09)
}
g10()
```

* But using the same name for different things is best avoided!

## A fresh start

* What happens to values between invocations of a function? 
* What will happen the first time you run this function?
* What will happen the second time?

```{r, results = "hide"}
g11 <- function() {
  if (!exists("a")) {
    a <- 1
  } else {
    a <- a + 1
  }
  a
}

g11()
g11()
```

## Dynamic lookup


* The output of a function can depend on objects outside its environment, because:
    * Lexical scoping determines where, not when, to look for values.
    * R looks for values when the function is run, not when the function is created. 

```{r}
g12 <- function() x + 1
x <- 15
g12()

x <- 20
g12()
```

* Can be quite annoying. 
    * With spelling mistakes, no error when creating a function.
    * Depending on the global environment, maybe not even an error when running the function. 

# Functional programming

## For loops vs. functionals

* To compute the mean of every column:

```{r}
output <- vector("double", length(df))
for (i in seq_along(df)) {
  output[[i]] <- mean(df[[i]])
}

output
```

* As a function:

```{r}
col_mean <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- mean(df[[i]])
  }
  output
}

col_mean(df)
```

## How about other quantities?

```{r}
col_median <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- median(df[[i]])
  }
  output
}

col_sd <- function(df) {
  output <- vector("double", length(df))
  for (i in seq_along(df)) {
    output[i] <- sd(df[[i]])
  }
  output
}

col_median(df)
col_sd(df)
```

* What's "wrong" here?

## A simple "functional"

```{r}
col_summary <- function(df, fun) {
  out <- vector("double", length(df))
  for (i in seq_along(df)) {
    out[i] <- fun(df[[i]])
  }
  out
}

col_summary(df, median)
col_summary(df, mean)
```

## The two programming paradigms

* __Imperative:__
    * The programmer instructs the machine how to change its state.
    * Examples:
        * __Procedural:__ groups instructions into procedures.
        * __Object-oriented:__ groups instructions together with the part of the state they operate on.
* __Declarative:__
    * The programmer declares properties of the desired result, but not how to compute it.
    * Examples:
        * __Functional:__ the output results of a series of function applications.
        * __Mathematical:__ the output is the solution of an optimization problem.

## What about R?

* A bit of everything:
    * Powerful but complex.
* Imperative:
    * Procedural: functions loaded with `source()`.
    * Object-oriented: the `S3` class system (and others).
* Declarative:
    * Mathematical: optimization with `optim` and specialized packages.
    * Functional: __the hearth__ of R.

## Functional programming languages

* Functional programming:
  * Uses __functions that return functions__ as output.
  * Passes functions as arguments to others function.
  * Much more in the [Advanced-R book chapter on FP](https://adv-r.hadley.nz/fp.html)
* What makes a programming language functional?
    * Many definitions but two common threads:
        * __First-class__ functions.
        * __Pure__ functions.
* __Functional style__:
    * Hard to describe exactly, but essentially:
        * Decompose a problem into small pieces, then solve each piece with a (combination of) function(s).
        * Each function is simple and straightforward to understand.
        * Complexity is handled by composing functions.


## First-class functions

* Functions behave like any other data structure.
* In R, means that you can:
    * Assign them to variables.
    * Store them in lists.
    * Pass them as arguments to other functions.
    * Create them inside functions.
    * And even return them as the result of a function.

```{r}
f1 <- function(x) x
l1 <- list(
  mean,
  sd,
  median
)
y <- rnorm(1e1)
sapply(l1, function(f) f(y))
```

## Pure functions

* Two main properties:
    * The output only depends on the inputs:
        * Call it again with the same inputs, get the same outputs.
        * Excludes functions like `runif()` or `read.csv()` (why?).
    * No side-effects:
        * E.g., no changing the value of a global  variable, writing to disk, or displaying to the screen.
        * Excludes functions like `print()`, `write.csv()` and `<-`.
* Two remarks:
    * Much easier to reason about, but some downsides:
        * How to do data analysis without generate random numbers or read files from disk?
    * Strictly speaking:
        * R isn't a functional _language_ (why?).
        * While you don't _have_ to write pure functions, you often _should_.

## Functional style

:::: {.columns}
::: {.column width='58%'}

* Three techniques:
    * __Functionals__:
        * Replace many loops.
        * E.g., `lapply()`, `sapply()`.
        * The most important, used all the time in data analysis.
    * __Function factories__:
        * Functions that create functions.
        * Partition work between different parts of your code.
    *  __Function operators__:
        * Functions that take/return functions as inputs/output.
        * Typically modify the operation of a function.

:::
::: {.column width='38%'}

* Called __higher-order functions__

\vspace{2cm}
```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics("figures/fp.png")
```

:::
::::

# Functionals

## Functionals

> To become significantly more reliable, code must become more transparent.
> In particular, nested conditions and loops must be viewed with great
> suspicion. Complicated control flows confuse programmers. Messy code often
> hides bugs.
>
> --- Bjarne Stroustrup

* __Functional__:
    * Takes/returns a function/vector as an input/output.
    * `lapply()`, `apply()`, `tapply()`, purrr's `map()`, `integrate()` or `optim()`.

```{r}
randomise <- function(f) f(runif(1e3))
randomise(mean)
randomise(mean)
randomise(sum)
```

<!-- A common use of functionals is as an alternative to for loops. For loops have a bad rap in R because many people believe they are slow[^not-slow], but the real downside of for loops is that they're very flexible: a loop conveys that you're iterating, but not what should be done with the results. Just as it's better to use `while` than `repeat`, and it's better to use `for` than `while`, it's better to use a functional than `for`. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it's being used. -->

## Outline

* `purrr::map()`:
    * The basic map functions
        * Take a vector as input.
        * Apply a function to each piece.
        * Return a new vector that's the same length (and has the same names) as the input.
    * The return type is determined by the suffix.
        * `map()`     makes a list.
        * `map_lgl()` makes a logical vector.
        * `map_int()` makes an integer vector.
        * `map_dbl()` makes a double vector.
        * `map_chr()` makes a character vector.
* `purrr::reduce()`.
* Predicates and the functionals using them.
* Mathematical functionals.
<!-- (functions returning a single `TRUE` or `FALSE`) -->
<!-- * Some functionals in base R not members of those families. -->
* Focus on the [purrr package](https://purrr.tidyverse.org):

```{r}
library(purrr)
```

## Warm-up: `purrr::map()`

* The most fundamental functional:
    * Takes a vector and a function.
    * Calls the function once for each element of the vector
    * Returns the results in a list.
* `map(1:3, f)` is equivalent to `list(f(1), f(2), f(3))`.
* The R base equivalent: `lapply()`.

:::: {.columns}
::: {.column width='48%'}

```{r}
triple <- function(x) x * 3
map(1:3, triple)
```

:::
::: {.column width='48%'}

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("figures/functionals/map.png")
```

:::
::::

<!-- ::: sidebar -->
<!-- You might wonder why this function is called `map()`. What does it have to do with depicting physical features of land or sea ? In fact, the meaning comes from mathematics where _map_ refers to "an operation that associates each element of a given set with one or more elements of a second set". This makes sense here because `map()` defines a mapping from one vector to another. (_"Map"_ also has the nice property of being short, which is useful for such a fundamental building block.) -->
<!-- ::: -->

<!-- [^Map]: Not to be confused with `base::Map()`, which is considerably more complex. I'll discuss `Map()` in Section \@ref(pmap). -->

## How does that work?

* Simple implementation:
    * Allocate a list the same length as the input.
    * Fill in the list with a for loop.

```{r}
simple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}
```

* A few differences for the real implementation:
    * Written in C for performance.
    * Preserves names
    * Supports a few shortcuts.


## Producing atomic vectors

* `map()` returns a list
* 4 more specific variants:
    * `map_dbl()`, `map_chr()`, `map_int()` and `map_lgl()`.

* `map_dbl()` always returns a double vector.

```{r}
map_dbl(mtcars, mean)
```

* `map_chr()` always returns a character vector

```{r}
map_chr(mtcars, typeof)
```

## Producing atomic vectors con'd

* `map_int()` always returns an integer vector.

```{r}
map_int(mtcars, function(x) length(unique(x)))
```

* `map_lgl()` always returns a logical vector.

```{r}
map_lgl(mtcars, is.double)
```

:::: {.columns}
::: {.column width='53%'}

* Remarks:
    * Suffixes refer to the output.
    * But `map_*()` can take any type of vector as input.
* Examples rely on two facts:
    * `mtcars` is a data frame.
    * data frames are lists containing vectors of the same length.

:::
::: {.column width='43%'}

```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics("figures/functionals/map-list.png")
```

:::
::::

## Producing atomic vectors con'd

* Each call to the function must return a single value.

```{r, error = TRUE}
map_dbl(1:2, function(x) c(x, x))
```

* And obviously return the correct type.

```{r, error = TRUE}
map_dbl(1:2, as.character)
```

* In either case, use `map()` to see the problematic output!
<!-- * In base R: -->
<!--     * `sapply()`. -->
<!--         * Tries to simplify the result,. -->
<!--         * Can return a list, a vector, or a matrix. -->
<!--         * Difficult to program with, avoid in non-interactive settings. -->
<!--     * `vapply()`. -->
<!--         * `FUN.VALUE` to describe the output shape. -->
<!--         * Verbosity: `vapply(x, mean, na.rm = TRUE, FUN.VALUE = double(1))` for `map_dbl(x, mean, na.rm = TRUE)`. -->

## Anonymous functions and shortcuts

* `map` can use anonymous functions.

```{r}
map_dbl(mtcars, function(x) length(unique(x)))
```

* Less verbose shortcut.

```{r}
map_dbl(mtcars, ~ length(unique(.x)))
```

* Useful for generating random data.

```{r}
x <- map(1:3, ~ runif(2))
str(x)
```

* Rule of thumb: a function spans lines/uses `{}`, give it a name.

## Passing arguments with `...`

:::: {.columns}
::: {.column width='48%'}

* To pass along additional arguments, use an anonymous function.

```{r}
x <- list(1:5, c(1:10, NA))
map_dbl(x, ~ mean(.x, na.rm = TRUE))
```


* Or the simpler form.

```{r}
map_dbl(x, mean, na.rm = TRUE)
```

:::
::: {.column width='48%'}

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("figures/functionals/map-arg.png")
```

:::
::::


* A subtle difference.

```{r}
plus <- function(x, y) x + y
x <- c(0, 0, 0, 0)

map_dbl(x, plus, runif(1))

map_dbl(x, ~ plus(.x, runif(1)))
```

## Map variants

* 23 primary variants of `map()`:
    * `map()`, `map_dbl()`, `map_chr()`, `map_int()`, `map_lgl()`
    * 18 (!!) more to learn.
    * Five new ideas:
        * Output same type as input with `modify()`
        * Iterate over two inputs with `map2()`.
        * Iterate with an index using `imap()`
        * Return nothing with `walk()`.
        * Iterate over any number of inputs with `pmap()`.

<!-- The map family of functions has orthogonal input and outputs, meaning that we can organise all the family into a matrix, with inputs in the rows and outputs in the columns. Once you've mastered the idea in a row, you can combine it with any column; once you've mastered the idea in a column, you can combine it with any row. That relationship is summarized in the following table: -->

\scriptsize

|                       | List     | Atomic            | Same type   | Nothing   |
|-----------------------|----------|-------------------|-------------|-----------|
| One argument          | `map()`  | `map_lgl()`, ...  | `modify()`  | `walk()`  |
| Two arguments         | `map2()` | `map2_lgl()`, ... | `modify2()` | `walk2()` |
| One argument + index  | `imap()` | `imap_lgl()`, ... | `imodify()` | `iwalk()` |
| N arguments           | `pmap()` | `pmap_lgl()`, ... | ---         | `pwalk()` |

<!-- ## Same type of output/input: `modify()` -->

<!-- ```{r} -->
<!-- df <- data.frame(x = 1:3, y = 6:4) -->

<!-- map(df, ~ .x * 2) -->

<!-- modify(df, ~ .x * 2) -->
<!-- ``` -->

<!-- * A simple implementation. -->

<!-- ```{r} -->
<!-- simple_modify <- function(x, f, ...) { -->
<!--   for (i in seq_along(x)) { -->
<!--     x[[i]] <- f(x[[i]], ...) -->
<!--   } -->
<!--   x -->
<!-- } -->
<!-- ``` -->

## Two inputs: `map2()` and friends

* How do we find the vector of weighted means?

```{r}
xs <- map(1:8, ~ runif(10))
xs[[1]][[1]] <- NA
ws <- map(1:8, ~ rpois(10, 5) + 1)
```

* Use `map_dbl()` to compute the unweighted means.

```{r}
map_dbl(xs, mean)
```

* Passing `ws` as an additional argument doesn't work.

```{r, error = TRUE}
map_dbl(xs, weighted.mean, w = ws)
```

```{r, echo = FALSE, out.width = "40%"}
knitr::include_graphics("figures/functionals/map-arg-recycle.png")
```

## `map2()` and friends cont'd


* Both arguments are varied in each call.

```{r}
map2_dbl(xs, ws, weighted.mean)
```

* Additional arguments still go afterwards.

```{r}
map2_dbl(xs, ws, weighted.mean, na.rm = TRUE)
```

:::: {.columns}
::: {.column width='48%'}

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("figures/functionals/map2.png")
```

:::
::: {.column width='48%'}


```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("figures/functionals/map2-arg.png")
```

:::
::::

## Any number of inputs: `pmap()`

* `map()` and `map2()`... `map3()`, `map4()`, `map5()`?
* Instead, there is `pmap()`:
    * Supply it a single list, which contains any number of arguments.
    * In most cases, a list of equal-length vectors (e.g., a data frame).

:::: {.columns}
::: {.column width='48%'}

```{r}
params <- tibble::tribble(
  ~ n, ~ min, ~ max,
   1L,     0,     1,
   2L,    10,   100,
   3L,   100,  1000
)

pmap(params, runif)
```

:::
::: {.column width='48%'}

```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics("figures/functionals/pmap-3.png")
```

:::
::::

## Reduce family

* The next most important (family of) functionals.
    * Much smaller (two main variants).
    * Powers the map-reduce framework.
* `purrr::reduce()`:
    * Takes a vector of length _n_.
    * Produces a vector of length 1 by calling a function with a pair of values at a time.
    * `reduce(1:4, f)` is equivalent to `f(f(f(1, 2), 3), 4)`.

```{r, echo = FALSE, out.width="40%"}
knitr::include_graphics("figures/functionals/reduce.png")
```

## Reduce family cont'd

* Useful to generalize a function that works with two inputs to work with any number of inputs.
* Problem: find the values that occur in every element.

```{r}
l <- map(1:4, ~ sample(1:10, 15, replace = TRUE))
str(l)
```

* Two solutions:

:::: {.columns}
::: {.column width='48%'}

```{r}
out <- l[[1]]
out <- intersect(out, l[[2]])
out <- intersect(out, l[[3]])
out <- intersect(out, l[[4]])
out
```

:::
::: {.column width='48%'}

```{r}
reduce(l, intersect)
```

:::
::::

## Accumulate

```{r}
accumulate(l, intersect)

x <- c(4, 3, 10)
reduce(x, `+`)
reduce(x, `+`) == sum(x)
accumulate(x, `+`)
accumulate(x, `+`) == cumsum(x)
```

## Predicate functionals

* A __predicate__:
    * Function that returns a single `TRUE` or `FALSE`.
    * E.g., `is.character()`, `is.null()`, or `all()`.
    * __Matches__ a vector if it returns `TRUE`.
* A __predicate functional__:
    * `f(x, p)` applies a predicate `p` to each element of a vector `x`.
    *   `some()`/`every()`: `TRUE` if _any/all_ element matches.
        <!-- * Similar to `any(map_lgl(.x, .p))`/`all(map_lgl(.x, .p))`. -->
        <!-- * But terminate early. -->
    * `detect()`/`detect_index()`: _value/location_ of the first match.
    * `keep()`/`discard()`: _keeps/drops_ all matching elements.

```{r}
df <- tibble(x = 1:3, y = c("a", "b", "c"))
```

:::: {.columns}
::: {.column width='48%'}

```{r}
detect(df, is.character)
```

:::
::: {.column width='48%'}

```{r}
detect_index(df, is.character)
```

:::
::::

\vspace{0.2cm}

:::: {.columns}
::: {.column width='48%'}

```{r}
keep(df, is.character)
```

:::
::: {.column width='48%'}

```{r}
discard(df, is.character)
```

:::
::::

## Mathematical functionals

```{r}
integrate(sin, 0, pi)
str(uniroot(sin, pi * c(1 / 2, 3 / 2)))
str(optimise(sin, c(0, 2 * pi)))
str(optimise(sin, c(0, pi), maximum = TRUE))
```

# Function operators

## Function operators

* Functions that takes one (or more) functions as input and returns a function as output.

```{r, eval = TRUE}
chatty <- function(f) {
  function(x, ...) {
    cat("Processing ", x, "\n", sep = "")
    f(x, ...)
  }
}

f <- function(x) x ^ 2
map_dbl(c(3, 2, 1), chatty(f))
```

* For Python users: decorators is just another name!

## Dealing with failure using `safely()`

* The modified function always returns a list with two elements:
    1. `result` is the original result.
    2. `error` is an error object.

```{r}
safe_log <- safely(log)
str(safe_log(10))
str(safe_log("a"))
```


## `safely()` and `map()`

```{r}
x <- list(1, 10, "a")
y <- map(x, safely(log))
str(y)
```

## `transpose()`

```{r}
y <- transpose(y)
str(y)
```

```{r, echo = FALSE, out.width = "50%"}
knitr::include_graphics("figures/lists-transpose.png")
```

## Typical use

```{r}
is_ok <- map_lgl(y$error, is_null)
x[!is_ok]
flatten_dbl(y$result[is_ok])
```

## Two other useful adverbs

* `possibly()`: "simpler" than `safely()`, because you give it a default value to return when there is an error.

```{r}
map_dbl(x, possibly(log, NA_real_))
```

* `quietly()`: instead of capturing errors, it captures printed output, messages, and warnings.

```{r}
map(list(1, -1), quietly(log)) %>% str()
```

## Caching computations with `memoise()`

* Provided by the `memoise` package.
* __Memoises__ a function
    * The function remembers previous inputs/returns cached results.
    * Classic CS tradeoff of memory versus speed:
        * A memoised function is faster, but uses more memory.

:::: {.columns}
::: {.column width='48%'}

```{r, cache = TRUE}
slow_fct <- function(x) {
  Sys.sleep(1)
  x * 10 * runif(1)
}

system.time(print(slow_fct(1)))
system.time(print(slow_fct(1)))
```

:::
::: {.column width='48%'}

```{r, cache = TRUE}
library(memoise)
fast_fct <- memoise(slow_fct)



system.time(print(fast_fct(1)))
system.time(print(fast_fct(1)))
```

:::
::::

## Fibonacci series

* Defined recursively:
    * $f(0) = 0$, $f(1) = 1$,
    * And then $f(n) = f(n - 1) + f(n - 2)$.

:::: {.columns}
::: {.column width='48%'}

```{r, cache = TRUE}
fib <- function(n) {
  if (n < 2) return(1)
  fib(n - 2) + fib(n - 1)
}

system.time(fib(23))
system.time(fib(24))
```

:::
::: {.column width='48%'}

```{r, cache = TRUE}
fib2 <- memoise(function(n) {
  if (n < 2) return(1)
  fib2(n - 2) + fib2(n - 1)
})

system.time(fib2(23))
system.time(fib2(24))
```

:::
::::

* An example of __dynamic programming__:
    * Complex problem broken down into overlapping subproblems.
    * Remembering the results of a subproblem considerably improves performance.

<!-- ## Exit handlers -->

<!-- * The context: -->
<!--     * Sometimes a function needs to make temporary changes to the global state. -->
<!--     * But having to cleanup those changes can be painful (what happens if there's an error?).  -->
<!--     * To ensure that these changes are undone and that the global state is restored no matter how a function exits,  -->
<!-- * Use `on.exit()` to set up an __exit handler__.  -->

<!-- ```{r, error = TRUE} -->
<!-- j06 <- function(x) { -->
<!--   cat("Hello\n") -->
<!--   on.exit(cat("Goodbye!\n"), add = TRUE) -->

<!--   if (x) { -->
<!--     return(10) -->
<!--   } else { -->
<!--     stop("Error") -->
<!--   } -->
<!-- } -->

<!-- j06(TRUE) -->

<!-- j06(FALSE) -->
<!-- ``` -->

<!-- ## Exit handlers with `on.exit()` -->

<!-- * Always set `add = TRUE`: -->
<!--     * If you don't, each call to `on.exit()` overwrites previous ones. -->
<!--     * Even when only registering a single handler, it's good practice to set `add = TRUE`. -->
<!-- * `on.exit()` is useful because it allows to place clean-up code directly next to the code that requires clean-up. -->

<!-- ```{r} -->
<!-- cleanup <- function(dir, code) { -->
<!--   old_dir <- setwd(dir) -->
<!--   on.exit(setwd(old_dir), add = TRUE) -->

<!--   old_opt <- options(stringsAsFactors = FALSE) -->
<!--   on.exit(options(old_opt), add = TRUE) -->
<!-- } -->
<!-- ``` -->

<!-- ## Exit handlers with `on.exit()` cont'd -->

<!-- * Coupled with lazy evaluation, a useful pattern for running a block of code in an altered environment. -->

<!-- ```{r} -->
<!-- with_dir <- function(dir, code) { -->
<!--   old <- setwd(dir) -->
<!--   on.exit(setwd(old), add = TRUE) -->

<!--   force(code) -->
<!-- } -->

<!-- getwd() -->
<!-- with_dir("~", getwd()) -->
<!-- getwd() -->
<!-- ``` -->

<!-- * `force()` isn't strictly necessary here as simply referring to `code` will force its evaluation. -->
<!-- * But makes it clear that we are deliberately forcing the execution. -->

<!-- The withr package [@withr] provides a collection of other functions for setting up a temporary state. -->

<!-- In R 3.4 and earlier, `on.exit()` expressions are always run in order of creation: -->

<!-- ```{r} -->
<!-- j08 <- function() { -->
<!--   on.exit(message("a"), add = TRUE) -->
<!--   on.exit(message("b"), add = TRUE) -->
<!-- } -->
<!-- j08() -->
<!-- ``` -->

<!-- This can make cleanup a little tricky if some actions need to happen in a specific order; typically you want the most recent added expression to be run first. In R 3.5 and later, you can control this by setting `after = FALSE`: -->

<!-- ```{r, eval = getRversion() >= "3.5"} -->
<!-- j09 <- function() { -->
<!--   on.exit(message("a"), add = TRUE, after = FALSE) -->
<!--   on.exit(message("b"), add = TRUE, after = FALSE) -->
<!-- } -->
<!-- j09() -->
<!-- ``` -->