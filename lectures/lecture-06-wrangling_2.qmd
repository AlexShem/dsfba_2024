---
title: "Data Science in Business Analytics"
subtitle: "Data Wrangling -- 2"
author: "Professor Alex [aleksandr.shemendyuk@unil.ch]"
date: "04/11/2024"
format: 
    beamer:
        include-in-header: ../latex/header.tex
        fontsize: 10pt
execute:
    echo: true
---


```{r setup}
#| echo: false
#| include: false

source("../R/common.R")
library(tidyverse)
library(knitr)
library(nycflights13)
```

## Today

```{r echo = FALSE, out.width = "90%"}
include_graphics("../assets/r4ds/data-science-wrangle.png")
```


## Outline

\tableofcontents


# Relational data

## Relational Data

- **Until now**: Analysis of a single table of data.
- **Typically**: In practice, data often spans multiple tables that need to be combined.
- **Definition**: This is known as _relational data_:
  - The relationships between tables, not just the individual datasets, are key.
- **Relations**:
  - Defined between pairs of tables.
  - Relationships involving three or more tables are constructed from these pairwise relations.

## Relational Database Systems

- Common relational database systems include:
  - Oracle, MySQL, Microsoft SQL Server, PostgreSQL, IBM DB2, Microsoft Access, SQLite, and others.

```{r, echo = FALSE, out.width = "50%"}
knitr::include_graphics("../assets/sql-history.png")
```

## Datasets Used from `nycflights13`

- In this section, we introduce the datasets from the `nycflights13` package, which will be used for exploring relational data operations.
- These datasets include information on
  - flights,
  - airlines,
  - airports,
  - planes, 
  - and weather data.

---

## `nycflights13::flights`

- Contains `r format(nrow(nycflights13::flights), big.mark = "'")` flights that departed from NYC in 2013:

```{r}
flights
```

---

## `nycflights13::airlines`

Displays airline information corresponding to each carrier in the `flights` dataset:

```{r}
airlines
```

---

## `nycflights13::airports`

Provides details about each airport, including geographic location and other identifying information:

```{r}
airports
```

---

## `nycflights13::planes`

Contains information on the planes used in the flights, including the manufacturer and year built:

```{r}
planes
```

---

## `nycflights13::weather`

Records weather conditions in NYC airports at the time of each flight's departure:

```{r}
weather
```

## `nycflights13`: Relationships Summary

```{r, echo = FALSE}
knitr::include_graphics("../assets/r4ds/relational.png")
```

## Keys: Primary and Foreign

**Keys** connect two tables by linking variables.

- **Primary Key**: Uniquely identifies each observation within its own table.
  - Examples:
    - `airlines$carrier` in `airlines`.
    - `airports$faa` in `airports`.
    - `planes$tailnum` in `planes`.
    - Compound keys: `weather$origin` and `weather$time_hour` in `weather`.

---

## Foreign Keys and Table Relationships

- **Foreign Key**: Links to a primary key in another table.
  - Examples:
    - `flights$tailnum` links to `planes$tailnum`.
    - `flights$carrier` links to `airlines$carrier`.
    - Compound keys like `flights$origin` and `flights$time_hour` link to `weather$origin` and `weather$time_hour`.

- **Naming Convention**: Primary and foreign keys often share names, simplifying table joins.

## Verifying Primary Keys

To confirm that a key is primary, we check:

- **Uniqueness**: Each key should uniquely identify an observation.

```{r}
planes |>
    count(tailnum) |>
    filter(n > 1)
```

- **No Missing Values**: A primary key must not contain `NA` values.

```{r}
planes |>
    filter(is.na(tailnum))
```

## Surrogate Keys

- **Complex Keys**: Some tables lack a simple primary key, requiring a combination of variables to uniquely identify rows.
  - For `flights`, the combination `time_hour`, `carrier`, and `flight` uniquely identifies each observation.

```{r}
flights |>
    count(time_hour, carrier, flight) |>
    filter(n > 1)
```

---

## Creating a Surrogate Key

- **Surrogate Key**: A simpler, unique identifier can be generated to make referencing observations easier.
  - Adding a numeric ID as a surrogate key for each row in `flights`:

```{r}
flights2 <- flights |>
    mutate(id = row_number(), .before = 1)
flights2
```

<!-- ## No explicit primary key? -->

<!-- ```{r} -->
<!-- flights |> -->
<!--     count(year, month, day, flight) |> -->
<!--     filter(n > 1) -->
<!-- ``` -->

<!-- * Solution: add one with `mutate()` and `row_number()`. -->
<!-- * This is called a __surrogate key__. -->

## Combining Tables

- Two main types of verbs for working with relational data:
  - **Mutating Joins**: Add new variables to a data frame based on matching observations in another.
  - **Filtering Joins**: Filter observations in a data frame depending on whether they match observations in another table.


## Technical Slide: Narrow `flights` Dataset

```{r}
flights2 <- flights |>
    select(year:day, hour, origin, dest, tailnum, carrier)

flights2
```

## Understanding Mutating Joins

```{r}
x <- tribble(~key, ~val_x,
             1, "x1",
             2, "x2",
             3, "x3")
y <- tribble(~key, ~val_y,
             1, "y1",
             2, "y2",
             4, "y3")
```

```{r, echo = FALSE, out.width = "50%"}
knitr::include_graphics("../assets/r4ds/join-setup2.png")
```

---

## Inner Join

An **inner join** retains only matching rows between tables `x` and `y`.

```{r, echo = FALSE, out.width = "90%"}
knitr::include_graphics("../assets/r4ds/join-inner.png")
```

```{r}
inner_join(x, y, join_by(key))
```

---

## Outer Joins

- **Outer Joins** retain observations appearing in at least one of the tables:
  - **Left join**: Keeps all observations from `x`.
  - **Right join**: Keeps all observations from `y`.
  - **Full join**: Keeps all observations from both `x` and `y`.
  
Outer joins introduce "virtual" observations with keys that match all unmatched rows, with missing values filled as `NA`.

---

## Outer Joins Illustrated

```{r, echo = FALSE, out.width = "50%"}
knitr::include_graphics("../assets/r4ds/join-outer.png")
```

---

## A Venn Diagram for Joins

This Venn diagram visually summarizes inner, left, right, and full joins:

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("../assets/r4ds/join-venn.png")
```

## Duplicate Keys

- When tables contain duplicate keys, two scenarios arise:
  - **One table has duplicate keys**:
    - Common in one-to-many relationships where additional information is added.
  - **Both tables have duplicate keys**:
    - Typically an error as keys no longer uniquely identify observations.
    - Joins produce all possible combinations (Cartesian product) when both tables have duplicate keys.

---

## One Table with Duplicate Keys

- Only `x` contains duplicated keys:

:::: {.columns}
::: {.column width='48%'}

```{r}
x <- tribble(~key, ~val_x,
             1, "x1",
             2, "x2",
             2, "x3",
             1, "x4")
```

:::
::: {.column width='48%'}

```{r}
y <- tribble(~key, ~val_y,
             1, "y1",
             2, "y2")
```

:::
::::

\vspace{0.5cm}

- Resulting join adds `val_y` to matching rows:

:::: {.columns}
::: {.column width='48%'}

```{r}
left_join(x, y, join_by(key))
```

:::
::: {.column width='48%'}

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("../assets/r4ds/join-one-to-many.png")
```

:::
::::

---

## Both Tables with Duplicate Keys

- Both `x` and `y` contain duplicated keys:

:::: {.columns}
::: {.column width='48%'}

```{r}
x <- tribble(~key, ~val_x,
             1, "x1",
             2, "x2",
             2, "x3",
             3, "x4")
```

:::
::: {.column width='48%'}

```{r}
y <- tribble(~key, ~val_y,
             1, "y1",
             2, "y2",
             2, "y3",
             3, "y4")
```

:::
::::

\vspace{0.5cm}

- Join results in all possible combinations:

:::: {.columns}
::: {.column width='48%'}

```{r}
left_join(x, y, join_by(key))
```

:::
::: {.column width='48%'}

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("../assets/r4ds/join-many-to-many.png")
```

:::
::::

## Specifying the Keys

- By default, `left_join()` uses all variables common to both tables as the join keys, performing what is called a **natural join**.
  - This is convenient but may not always produce the intended result.

```{r}
flights2 |>
    left_join(weather)
```

---

## Specifying Specific Join Keys

- Sometimes only a subset of the common variables should be used for joining.
  - In this example, we join `flights2` with `planes` using `tailnum` only, avoiding unintended matches on other common variables like `year`.

```{r}
flights2 |>
    left_join(planes, join_by(tailnum)) |> print(n = 5)
```

- Notice that the `year` columns are disambiguated with suffixes (`year.x` and `year.y`) to indicate the origin table.

---

## Custom Join Conditions

- We can specify joins with different variable names using `join_by(a == b)`.
  - Here, `left_join` matches `dest` in `flights2` with `faa` in `airports`.

```{r}
flights2 |>
    left_join(airports, join_by(dest == faa)) |> print(n = 5)
```

- This approach clarifies which keys are matched and supports more complex join requirements.

## Filtering Joins

Filtering joins affect the rows, not the columns:

- **`semi_join(x, y)`**: Keeps all rows in `x` that have a match in `y`.
  - Useful for filtering to matching observations in both tables.

- **`anti_join(x, y)`**: Drops all rows in `x` that have a match in `y`.
  - Useful for diagnosing mismatches, identifying records in `x` without a corresponding match in `y`.

---

## Flights to Top Destinations

To identify flights to top destinations, filter the `flights` data for destinations with high frequency:

```{r}
top_dest <- flights |>
    count(dest, sort = TRUE) |>
    head(10)

flights |>
    filter(dest %in% top_dest$dest) |>
    print(n = 5)
```

---

## Using Semi-Join

- `semi_join()` retains only rows in `flights` that match with rows in `top_dest`:

```{r}
semi_join(flights, top_dest, join_by(dest))
```

---

## Using Anti-Join

- `anti_join()` helps identify rows in `flights2` without matches in other tables, making it useful for detecting mismatches.

:::: {.columns}
::: {.column width='48%'}

- Finding destinations in `flights2` that are not listed in `airports`:

```{r}
flights2 |>
  anti_join(
    airports,
    join_by(dest == faa)
  ) |>
  distinct(dest)
```

:::
::: {.column width='48%'}

- Finding tail numbers in `flights2` that are not present in `planes`:

```{r}
flights2 |>
  anti_join(planes,
            join_by(tailnum)) |>
  distinct(tailnum) |> print(5)
```

:::
::::

## Visually Understanding the Semi-Join

- **One-to-Many**: A semi-join between tables with a one-to-many relationship.

```{r, echo = FALSE, out.width = "50%"}
knitr::include_graphics("../assets/r4ds/join-semi.png")
```

- **Many-to-Many**: A semi-join between tables with a many-to-many relationship.

```{r, echo = FALSE, out.width = "50%"}
knitr::include_graphics("../assets/r4ds/join-semi-many.png")
```

---

## `flights` Without a Match in `planes`

Using `anti_join()` to identify tail numbers in `flights` without matches in `planes`.

:::: {.columns}
::: {.column width='53%'}

```{r}
flights |>
  anti_join(planes, join_by(tailnum)) |>
  count(tailnum, sort = TRUE)
```

:::
::: {.column width='47%'}

```{r, echo = FALSE, out.width = "100%"}
knitr::include_graphics("../assets/r4ds/join-anti.png")
```

:::
::::


<!-- ## Exercise -->

<!-- 1. Install and load the `nycflights13` library and check that you can access -->
<!-- the tables -->
<!-- `airlines`, `airports`, `planes`, `weather`, `flights`. -->

<!-- 2. Find the 48 hours (over the course of the whole year) that have the worst delays. Cross-reference it with the weather data. Can you see any patterns? -->

<!-- 3. Add the latitude and the longitude of the origin and destination airport to flights. Is it easier to rename the columns before or after the join? -->

<!-- 4. Does every departing flight have corresponding weather data for that hour? -->


# Dates and Times

## Warm-Up: Rethinking Time

Let's start with a few quick questions about time:

- **Does every year have exactly 365 days?**
  - *Hint*: What happens every four years?

- **Does every day always have 24 hours?**
  - *Hint*: Consider daylight saving time adjustments.

- **Does every minute have 60 seconds?**
  - *Hint*: Some "special" minutes may surprise you!

Exploring dates and times might seem simple at first, but they can involve surprising complexity. Let’s dive in and see why!

---

## Referring to an Instant in Time

- **Two Types of Date/Time Data**:
  - **Date**: Represents a specific day (printed as `<date>` in tibbles).
  - **Date-Time**: Combines a date with a time to specify a precise instant (printed as `<dttm>` in tibbles).
    - Equivalent to `POSIXct` in base R.
    - Use date-times only when necessary as they are more complex due to time zones.

- **Tip**: Always use the simplest possible data type for your needs.

---

## Creating Dates and Date-Times

- The **`lubridate`** package simplifies working with dates and times in R.
  - As of `tidyverse 2.0.0`, `lubridate` is [part of the core tidyverse](https://www.tidyverse.org/blog/2023/03/tidyverse-2-0-0/).

```{r, message = FALSE}
library(lubridate)
today()    # Current date
now()      # Current date-time
```

---

## Additional Ways to Create Date/Times

- Common methods for creating date/time objects:
  - **From a string**.
  - **From individual date/time components**.
  - **From an existing date/time object**.

```{r, message = FALSE}
as_datetime(today())  # Convert date to date-time
as_date(now())        # Convert date-time to date
```

## Importing Dates and Date-Times

- **Automatic Parsing**: If a CSV file contains dates or date-times in ISO8601 format, `readr` will automatically detect them.

```{r}
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

---

## ISO8601 Standard

- **ISO8601**: International format for dates and times, with elements ordered from largest to smallest.
  - Date: `YYYY-MM-DD` (e.g., 2022-05-03)
  - Date-Time:
    - `YYYY-MM-DD HH:MM:SS`
    - `YYYY-MM-DDTHH:MM:SS`
  - Example: 4:26pm on May 3, 2022 as
    - `2022-05-03 16:26`
    - `2022-05-03T16:26`

---

## Custom Date Formats

- For non-ISO8601 formats, specify `col_types` with [`col_date()` or `col_datetime()`](https://readr.tidyverse.org/reference/parse_datetime.html#format-specification) and a [format string](https://r4ds.hadley.nz/datetimes#tbl-date-formats).

| Code | Meaning                  | Example        |
|------|---------------------------|----------------|
| `%Y` | 4-digit year              | `2021`        |
| `%y` | 2-digit year              | `21`          |
| `%m` | Month number              | `02`          |
| `%b` | Abbreviated month name    | `Feb`         |
| `%B` | Full month name           | `February`    |
| `%d` | Day (one or two digits)   | `2`           |
| `%H` | Hour (24-hour clock)      | `13`          |
| `%I` | Hour (12-hour clock)      | `1`           |
| `%p` | AM/PM                     | `pm`          |
| `%M` | Minutes                   | `35`          |
| `%S` | Seconds                   | `45`          |
| `%Z` | Time zone name            | `America/Chicago` |
| `%z` | Offset from UTC           | `+0800`       |

---

## Specifying Ambiguous Date Formats

- For ambiguous formats, use specific format strings:

```{r}
csv <- "
  date
  01/02/15
"
read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))
#> Interprets as "2015-01-02"

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))
#> Interprets as "2015-02-01"
```

- **Locale-Specific Parsing**: Use [`locale()`](https://readr.tidyverse.org/reference/locale.html) for non-English dates, especially with `%b` or `%B`.

## Creating Dates and Date-Times from Strings

- **`lubridate` Helpers**: Use `ymd()`, `mdy()`, `dmy()`, etc., to parse dates automatically based on the order of year, month, and day.

```{r}
ymd("2017-01-31")            # Year-Month-Day
mdy("January 31st, 2017")     # Month-Day-Year
dmy("31-Jan-2017")            # Day-Month-Year
```

- **Creating Date-Times**: Add `_h`, `_m`, `_s` for hour, minute, second as needed.

```{r}
ymd_hms("2017-01-31 20:11:59")  # Year-Month-Day Hour:Minute:Second
mdy_hm("01/31/2017 08:01")      # Month-Day-Year Hour:Minute
```

---

- **Forcing Time Zones**: Specify `tz` to create date-times in a particular timezone, like UTC.

```{r}
ymd(20170131)                # Interprets as date "2017-01-31"
ymd(20170131, tz = "UTC")    # Interprets as date-time in UTC
```

## Creating Dates and Date-Times from Components

- Sometimes, date and time components are in separate columns. Use [`make_datetime()`](https://lubridate.tidyverse.org/reference/make_datetime.html) to combine them into a single date-time.

```{r}
flights |>
  select(year:day, hour, minute, dep_time) |>
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

---

## Handling Special Formats (e.g., `dep_time`)

- For columns like `dep_time` (e.g., 531 for 5:31 am), use modulus arithmetic to split hour and minute components.

```{r}
flights_dt <- flights |>
  mutate(dep_time = make_datetime(
    year, month, day, dep_time %/% 100, dep_time %% 100))
```

- This approach allows creation of consistent date-time columns from component columns, ready for analysis.

## Rounding Dates and Times

- Use [rounding functions](https://lubridate.tidyverse.org/reference/round_date.html) to simplify date-time values by rounding to a specified unit:
  - **`floor_date()`**: Rounds down to the nearest unit.
  - **`round_date()`**: Rounds to the nearest unit.
  - **`ceiling_date()`**: Rounds up to the nearest unit.

:::: {.columns}
::: {.column width='50%'}

```{r}
flights_dt_plot <- flights_dt |>
  filter(!is.na(dep_time)) |>
  count(
    week = floor_date(dep_time, "week")
  ) |>
  ggplot(aes(week, n)) +
  geom_line()
```

:::
::: {.column width='50%'}

```{r, echo=FALSE, out.width="100%"}
flights_dt_plot
```

:::
::::

- In this example, `floor_date()` rounds `dep_time` down to the start of each week, making it easy to plot weekly counts of departures.

## Getting and Setting Date-Time Components

**Extracting Components**

- Use accessor functions to get individual parts of a date-time:
  - `year()`, `month()`, `mday()` (day of month), `yday()` (day of year), `wday()` (day of week), `hour()`, `minute()`, `second()`

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")
c(year(datetime), month(datetime, label = TRUE), 
  mday(datetime), yday(datetime))

wday(datetime, label = TRUE, abbr = FALSE)
```

---

**Modifying Components**

- Use these same functions to adjust components:

```{r}
year(datetime) <- 2020
month(datetime) <- 1
hour(datetime) <- hour(datetime) + 1
datetime
```

- **Note**: Changing a component will automatically roll over if values exceed their normal limits.

---

**Alternative: Using `update()`**

- The [`update()`](https://rdrr.io/r/stats/update.html) function allows you to modify multiple components at once:

```{r}
update(datetime, year = 2030, month = 2, mday = 2, hour = 2)
```

This approach is useful when multiple updates are needed, ensuring clean and efficient code.

## Time Spans

- **Goal**: Perform arithmetic operations (addition, subtraction, division) with dates and times.
- Three main classes for handling time spans in `lubridate`:
  - **Durations**: Represent exact time spans in seconds.
  - **Periods**: Represent human units like days, weeks, or months.
  - **Intervals**: Define a specific time span between a start and end date.

::: {.callout-tip}
Choose the simplest class that meets your needs:

- **Physical time** → Duration.
- **Human time units** → Period.
- **Exact time span between points** → Interval.
:::

## Durations

- A **duration** always records a time span in seconds, using fixed conversions for larger units:
  - **Conversions**: 60s/minute, 60min/hour, 24h/day, 7d/week, 365.25d/year

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

---

## Duration Arithmetic

- **Basic Operations**: Add and multiply durations to combine them flexibly.

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

- **Date Arithmetic**: Add or subtract durations from dates/datetimes.

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

```{r}
#| echo: false

tomorrow
last_year
```

---

- **Daylight Saving Time Example**: DST can affect exact durations.

```{r}
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm
one_pm + ddays(1)
```

- Here, adding one day shifts the time due to DST, highlighting the difference between calendar days and fixed-second durations.

## Periods

- **Periods** represent time spans in "human" units, like days, months, and years (unlike durations, they don’t have a fixed length in seconds).

```{r}
seconds(15)
minutes(10)
hours(c(12, 24))
days(7)
months(1:3)
weeks(3)
years(1)
```

---

## Period Arithmetic

- **Add and multiply** periods to handle flexible time spans.

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

- **Date-Time Addition**: Periods adapt to calendar-based changes like leap years and daylight saving.

```{r}
# Leap year behavior
ymd("2016-01-01") + dyears(1)  # Fixed duration in seconds
ymd("2016-01-01") + years(1)   # Calendar-aware

# Daylight Saving Time adjustment
one_pm + ddays(1)    # Exact duration
one_pm + days(1)     # Period handling
```

## Understanding Intervals

- **Intervals** represent a time span with a specified starting and ending point.
  - Helpful for precise calculations that depend on specific dates.

- **Example of Estimation**:
  - Using `years(1) / days(1)` gives an estimated answer based on an average year length of 365.25 days.

```{r}
years(1) / days(1)
```

- To achieve a more accurate result, we need an interval.

---

## Creating and Using Intervals

- **Accurate Calculation with Intervals**:
  - Define an interval from today to the same date next year to find the exact number of days:

```{r}
next_year <- today() + years(1)
(today() %--% next_year) / ddays(1)  # Exact days until same date next year
```

- **Leap Year Example**:
  - Calculate days in 2023 vs. 2024 (a leap year):

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023 / days(1)  # Returns 365 for 2023
y2024 / days(1)  # Returns 366 for leap year 2024
```

Intervals allow precise calculations when calendar variations, such as leap years, affect durations.

## Summary

- **Choosing the Right Time Structure**:
  - **Duration**: Use when working with exact time measurements in seconds (e.g., physical elapsed time).
  - **Period**: Use when working with human-centric time spans, such as adding weeks or months.
  - **Interval**: Use when calculating the precise time span between two specific dates, taking into account calendar variations (e.g., leap years).

```{r, echo = FALSE, out.width = "90%"}
knitr::include_graphics("../assets/r4ds/datetimes-arithmetic.png")
```

## Time Zones

- **Understanding Time Zones**: R uses the IANA time zone database, which identifies time zones by `{continent}/{city}`, e.g., `America/New_York`.
  - Check your system’s time zone and see the full list:

```{r}
Sys.timezone()          # Current system time zone
length(OlsonNames())    # Total number of time zones
head(OlsonNames())      # Sample of time zones
```

---

## Representing the Same Instant in Different Time Zones

- **Same instant, different time zones**:

```{r}
(x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))
(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
(x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))

# Verifying identical instants
x1 - x2  # 0 secs
x1 - x3  # 0 secs
```

- **Combining Date-Times**: Using `c()` can unify times to the first element’s time zone:

```{r}
x4 <- c(x1, x2, x3)
x4
```

---

## Changing the Time Zone Display

- **Keep the Instant in Time**: Use `with_tz()` to adjust the time zone display without changing the instant.

```{r}
x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
x4a
x4a - x4   # 0 seconds difference
```

---

## Adjusting the Instant in Time

- **Change the Instant in Time**: Use `force_tz()` when the original time zone is incorrect, altering the actual time.

```{r}
x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
x4b - x4   # Difference in hours (14.5 in this case)
```

- **Note**: Time zone offsets can vary by non-integer hours, as seen with `+1030` for Lord Howe.

# Factors

## Introduction to Factors

- **Factors** are used for working with **categorical variables**:
  - Categorical variables have a **fixed, known set of possible values** (e.g., days of the week, levels of satisfaction).
  - Factors allow control over the display and ordering of categorical data, even when it’s not alphabetical.

- [**The `forcats` Package**](https://forcats.tidyverse.org/):
  - Part of the tidyverse, `forcats` provides a range of helpful functions for creating and manipulating factors.

```{r}
library(forcats)
```

---

## Why Use Factors?

- Factors are particularly useful for:
  - Displaying categories in a **custom order** rather than alphabetical.
  - **Reducing memory usage** when working with large categorical datasets by encoding categories.

This section will explore how to create and work with factors effectively.

## Creating Factors

- Imagine a variable recording the month:

```{r}
x1 <- c("Dec", "Apr", "Jan", "Mar")
```

- Using strings to store categorical data can lead to:
  - Typos that go unnoticed.
  - Sorting that’s not useful for meaningful categories.

```{r}
sort(x1)  # Alphabetical order, not chronological
```

---

## Defining Factor Levels

- First, define the valid **levels** in the correct order:

```{r}
month_levels <- c("Jan", "Feb", "Mar", "Apr", "May", "Jun",
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec")
```

- Then, create a factor:

```{r}
y1 <- factor(x1, levels = month_levels)
y1
sort(y1)       # Sorts in chronological order
factor(x1)     # Without specified levels, uses alphabetical order
```

---

## Handling Typos and Custom Order

- Values not in the specified levels are set to `NA`:

```{r}
x2 <- c("Dec", "Apr", "Jam", "Mar")
y2 <- factor(x2, levels = month_levels)
y2  # "Jam" becomes <NA> due to invalid level
```

- **Custom Orders**:
  - Factor created based on appearance order:

```{r}
factor(x1, levels = unique(x1))  # Custom order by appearance
factor(x1) |>
  fct_inorder()                 # Using forcats helper for order
```

Specifying levels helps avoid errors, ensures meaningful order, and makes factors a powerful tool for categorical data.

## Using `forcats::gss_cat`

- **`gss_cat`**: A sample dataset from the [General Social Survey](http://gss.norc.org), focusing on social, economic, and demographic data.

```{r}
gss_cat
```

- View more details about this dataset with `?gss_cat`.

---

## Viewing Factor Levels in `gss_cat`

:::: {.columns}
::: {.column width='48%'}

- **Plotting Factor Levels**: Create a barplot to visualize distribution.

```{r, out.width = "100%"}
ggplot(gss_cat, aes(race)) +
  geom_bar()
```

:::
::: {.column width='48%'}

- **Counting Factor Levels**: Use `count()` to summarize factor levels.

```{r}
gss_cat |>
  count(race)
```

:::
::::

---

## Troubleshooting Factor Levels in Plots

- What’s wrong with this visualization?

```{r}
relig_summary <- gss_cat |>
  group_by(relig) |>
  summarize(age = mean(age, na.rm = TRUE),
            tvhours = mean(tvhours, na.rm = TRUE),
            n = n())

ggplot(relig_summary, aes(tvhours, relig)) +
  geom_point()
```

- Consider whether the order of factor levels affects interpretation. Adjusting levels can improve clarity in plots.

## Modifying Factor Order

- **Reordering Factors by a Variable**: Use [`fct_reorder()`](https://forcats.tidyverse.org/reference/fct_reorder.html) to order factor levels based on another variable’s values.

```{r}
relig_summary |>
  mutate(relig = fct_reorder(relig, tvhours)) |>
  ggplot(aes(tvhours, relig)) +
  geom_point()
```

---

## Modifying Factor Order for Frequency

- **Order by Frequency**: Use [`fct_infreq()`](https://forcats.tidyverse.org/reference/fct_inorder.html) to order factor levels by their frequency, then reverse with [`fct_rev()`](https://forcats.tidyverse.org/reference/fct_rev.html).

```{r, fig.width=10}
gss_cat |>
  mutate(marital = marital |> fct_infreq() |> fct_rev()) |>
  ggplot(aes(marital)) +
  geom_bar()
```

## Modifying Factor Levels

- Beyond reordering, **changing factor levels** allows:
  - **Clarifying labels** for readability or publication.
  - **Collapsing levels** for higher-level summaries.

- Example: Counting the current levels in `partyid`.

```{r}
gss_cat |>
  count(partyid)
```

---

## Recoding Factor Levels

- **Using [`fct_recode()`](https://forcats.tidyverse.org/reference/fct_recode.html)** to rename levels for clarity:

```{r}
gss_cat |>
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat")) |>
  count(partyid)
```

---

## Collapsing Factor Levels

- Combine multiple old levels into a single new level using [`fct_recode()`](https://forcats.tidyverse.org/reference/fct_recode.html):

```{r}
gss_cat |>
  mutate(partyid = fct_recode(partyid,
    "Republican, strong" = "Strong republican",
    "Republican, weak"   = "Not str republican",
    "Other"              = "No answer",
    "Other"              = "Don't know",
    "Other"              = "Other party")) |>
  count(partyid)
```

---

## Simplifying Factor Levels with `fct_collapse()`

- **[`fct_collapse()`](https://forcats.tidyverse.org/reference/fct_collapse.html)** is ideal for grouping several levels together.

```{r}
gss_cat |>
  mutate(partyid = fct_collapse(partyid,
    other = c("No answer", "Don't know", "Other party"),
    rep = c("Strong republican", "Not str republican"),
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),
    dem = c("Not str democrat", "Strong democrat")
  )) |>
  count(partyid)
```

---

## Lumping Small Categories with `fct_lump()`

- **[`fct_lump()`](https://forcats.tidyverse.org/reference/fct_lump.html)** groups less common levels into “Other” to simplify plots.

```{r}
gss_cat |>
  mutate(relig = fct_lump(relig)) |>
  count(relig)

# Or keep the top 3 most common levels
gss_cat |>
  mutate(relig = fct_lump(relig, n = 3)) |>
  count(relig, sort = TRUE)
```

# Strings

## Basics of Strings in R

- **Creating Strings**: Use either double quotes `"` or single quotes `'` to define strings.

```{r}
string1 <- "This is a string"
string2 <- 'To get a "quote" inside a string, use single quotes'
```

- **Escape Character**: The backslash `\` allows you to include special characters:
  - `\"` for double quotes, `\'` for single quotes, `\\` for a backslash.

```{r}
double_quote <- "\""   # or '"'
single_quote <- '\''   # or "'"
```

---

## String Display vs. Content

- The displayed representation of a string in R may include escape characters.

```{r}
x <- c("\"", "\\")
x               # Displays escapes
writeLines(x)   # Raw contents without escapes
```

- Use `writeLines()` to view the actual contents of a string, bypassing escape characters in the display.

## Special Characters and Useful String Functions

- **Special Characters**:
  - `"\n"` for newline, `"\t"` for tab.
  - Check additional characters using `?'"'` or `?"'"`.

- **Examples**:

```{r}
(x <- "\u00b5")                   # Non-English character
c("one", "two", "three")          # Creating character vector
str_length(c("a", "R for data science", NA)) # Calculate string length
```

- **String Autocomplete**: `stringr` functions support autocomplete for easy access to string manipulation tools.

```{r, echo = FALSE}
knitr::include_graphics("../assets/r4ds/stringr-autocomplete.png")
```

---

## String Manipulation: Combining and Handling NA

:::: {.columns}
::: {.column width='48%'}

- **Combining Strings**: Use `str_c()` to concatenate strings.

```{r}
str_c("x", "y")
str_c("x", "y", "z")
str_c("x", "y", sep = ", ")
```

:::
::: {.column width='48%'}

- **Handling Missing Values**: Use `str_replace_na()` to replace `NA` in strings.

```{r}
x <- c("abc", NA)
str_c("|-", x, "-|")
str_c("|-", str_replace_na(x), "-|")
```

:::
::::

---

## String Recycling and Collapsing

- **Recycling**: Extend strings to match vector lengths.

```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

- **Collapsing Vectors**: Collapse elements of a character vector into a single string.

```{r}
str_c(c("x", "y", "z"), collapse = ", ")
```

## Subsetting strings

```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
str_sub(x, -3, -1)
str_sub("a", 1, 5)
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```

* See also `str_to_upper()` or `str_to_title()`.

## Locales and String Manipulation

- **Locales** affect how characters are treated based on language and regional rules.
  - Example: Turkish has two forms of the letter "i" — with and without a dot.
  - The capitalization behavior for these letters differs in Turkish.

```{r}
# Default (system locale)
str_to_upper(c("i", "ı"))

# Turkish locale specified
str_to_upper(c("i", "ı"), locale = "tr")
```

- **Setting Locale**:
  - Use an ISO 639 language code, a [two- or three-letter abbreviation](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).
  - If omitted, R uses the system’s default locale.

## Regular Expressions

> "Some people, when confronted with a problem, think  
> 'I know, I'll use regular expressions.'  
> Now, they have two problems."  
> — Jamie Zawinski

- **Regular expressions** (regex) are a powerful language for describing patterns in strings.
- **Regex Capabilities**:
  - **Match**: Identify strings that contain a specific pattern.
  - **Locate**: Find the exact positions where patterns occur in a string.
  - **Extract**: Retrieve the content that matches a pattern.
  - **Replace**: Substitute matches with a new value.
  - **Split**: Divide a string based on a pattern match.
- **Further Learning**:
  - [Read the chapter on regex from *R for Data Science*](https://r4ds.hadley.nz/regexps) for a comprehensive guide.
  
## Basic Pattern Matching in Regex

- **Exact Match**: The simplest patterns match exact strings.

```{r}
x <- c("apple", "banana", "pear")
str_view(x, "an")    # Matches "an" in the strings
```

- **Wildcard Character**: `.` matches any character (except newline).

```{r}
str_view(x, ".a.")   # Matches any character, "a", and another character
```

---

## Escaping Special Characters

- Since `.` matches any character, how do we match a literal `.`?
  - **Escape** it with `\\.`: backslash (`\`) is the escape character.

```{r}
# Define regex for matching a literal dot
dot <- "\\."  
writeLines(dot)      # Actual content is a single dot
str_view(c("abc", "a.c", "bef"), "a\\.c")  # Matches "a.c" only
```

---

## Matching Literal Backslashes

- To match a literal `\`, use `\\` as the regex.
  - **Double the escape**: to represent `\\`, use `\\\\` in the string.

```{r}
x <- "a\\b"
writeLines(x)         # Shows "a\b"
str_view(x, "\\\\")   # Matches a single literal backslash
```

## Anchors in Regex

- By default, regex patterns match any part of a string.
- **Anchors** help specify where in the string to match:
  - `^` for the **start** of a string.
  - `$` for the **end** of a string.

```{r}
x <- c("apple", "banana", "pear")
```

:::: {.columns}
::: {.column width='48%'}
- **Example: Start Anchor**  
```{r, out.width="20%"}
# Matches "a" at the start
str_view(x, "^a")
```
:::
::: {.column width='48%'}
- **Example: End Anchor**  
```{r, out.width="20%"}
# Matches "a" at the end
str_view(x, "a$")
```
:::
::::

---

## Matching the Entire String

- To match a complete string, use both `^` and `$`:

```{r}
x <- c("apple pie", "apple", "apple cake")
```

:::: {.columns}
::: {.column width='48%'}
- **Partial Match**  
```{r, out.width="20%"}
# Matches "apple" anywhere
str_view(x, "apple")
```
:::
::: {.column width='48%'}
- **Full String Match**  
```{r, out.width="20%"}
# Matches "apple" as the entire string
str_view(x, "^apple$")
```
:::
::::

## Character Classes and Alternatives

- **Special Patterns**:
  - `.`: Matches any character except newline.
  - `\\d`: Matches any digit (remember to escape `\`).
  - `\\s`: Matches any whitespace character.

- **Character Classes**:
  - `[abc]`: Matches `a`, `b`, or `c`.
  - `[^abc]`: Matches anything except `a`, `b`, or `c`.

- **Alternatives**:
  - Use `|` to match multiple patterns.
  - Example: `abc|def` matches `"abc"` or `"def"`.

---

## Character Classes in Practice

- Character classes provide flexibility in matching.

:::: {.columns}
::: {.column width='30%'}

- **Exact Character Match**  
```{r, out.width="20%"}
str_view(
  c(
    "abc", 
    "a.c", 
    "a*c", 
    "a c"
  ), 
  "a[.]c"
)
```

:::
::: {.column width='30%'}

- **Match a Specific Character**  
```{r, out.width="20%"}
str_view(
  c(
    "abc", 
    "a.c", 
    "a*c", 
    "a c"
  ), 
  ".[*]c"
)
```

:::
::: {.column width='30%'}

- **Match Spaces Explicitly**  
```{r, out.width="20%"}
str_view(
  c(
    "abc",
    "a.c",
    "a*c",
    "a c"
    ), 
  "a[ ]"
  )
```

:::
::::

---

## Using Alternatives

- **Alternatives** with `|` allow pattern flexibility.
  - Remember, `|` has low precedence.
  - `gr(e|a)y`: Matches both "grey" and "gray".

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

## Repetition in Regex

- Control the number of matches with these quantifiers:
  - `?`: Matches 0 or 1 times.
  - `+`: Matches 1 or more times.
  - `*`: Matches 0 or more times.

```{r}
# Example string: Longest year in Roman numerals
x <- "MDCCCLXXXVIII"
```

:::: {.columns}
::: {.column width='30%'}

- **Optional Match**  
```{r, out.width="100%"}
str_view(x, "CC?")
```
:::
::: {.column width='30%'}

- **One or More Matches**  
```{r, out.width="100%"}
str_view(x, "CC+")
```
:::
::: {.column width='30%'}

- **Match Group**  
```{r, out.width="100%"}
str_view(x, 'C[LX]+')
```
:::
::::

---

## Specifying Exact Match Counts

- **Precise Quantifiers**:
  - `{n}`: Exactly `n` matches.
  - `{n,}`: `n` or more matches.
  - `{n,m}`: Between `n` and `m` matches.

:::: {.columns}
::: {.column width='30%'}

- **Match Exactly 2**  
```{r, out.width="100%"}
str_view(x, "C{2}")
```
:::
::: {.column width='30%'}

- **Match 2 or More**  
```{r, out.width="100%"}
str_view(x, "C{2,}")
```
:::
::: {.column width='30%'}

- **Match Between 2 and 3**  
```{r, out.width="100%"}
str_view(x, "C{2,3}")
```
:::
::::

## Grouping and Backreferences

- Parentheses (`()`) in regex:
  - Organize complex patterns.
  - **Capture** parts of a match, storing them as **numbered groups**.

- **Backreferences**:
  - Refer back to previously captured groups using `\1`, `\2`, etc.

```{r}
str_view(fruit, "(..)\\1", match = TRUE)
```

- This example finds words with repeated pairs of letters, like "banana" or "cucumber".

---

## Grouping and Backreferences II

- More advanced patterns with backreferences:
  - Example: Finding words that start and end with the same letters:

```{r}
str_view(words, "^(..).*\\1$")
```

- **Reordering Using Capturing Groups**:
  - Use `str_replace()` with backreferences to reorder text, referencing each captured group.

```{r}
sentences |> 
  str_replace("(\\w+) (\\w+) (\\w+)", "\\1 \\3 \\2") |>
  head(2)
```

This example reorders the second and third words in sentences.

---

## Non-Capturing Groups

- **Non-capturing groups**:
  - Useful when you want to group patterns without capturing them, preventing unnecessary backreference groups.
  - Use `(?:...)` for non-capturing.

```{r}
x <- c("a gray cat", "a grey dog")
str_match(x, "gr(?:e|a)y")
```

- **Example**:
  - `(?:e|a)` specifies either "e" or "a" without creating an extra backreference group.

This can simplify patterns by omitting captures where they aren’t needed, while still using grouping to clarify complex regex structures.

<!-- * [Cool applications in chapter 14.4 of the 1st edition!](https://r4ds.had.co.nz/strings.html#tools) -->
